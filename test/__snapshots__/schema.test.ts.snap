// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Schema schema.grapqhl snapshot 1`] = `
"### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type Category {
  id: ID!
  name: String!
  posts(first: Int, last: Int, orderBy: [PostOrderByInput!], skip: Int, where: PostWhereInput): [Post!]!
}

input CategoryCreateInput {
  name: String!
  posts: CreateCategoriesPostsRelationInput
}

input CategoryCreateWithoutPostsInput {
  name: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  id: ID
  id_in: [ID!]
  name: String
  name_contains: String
  name_in: [String!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
}

input CreateCategoriesPostsRelationInput {
  connect: PostWhereInput
  create: [PostCreateWithoutCategoriesInput!]
}

input CreatePostsCategoriesRelationInput {
  connect: CategoryWhereInput
  create: [CategoryCreateWithoutPostsInput!]
}

input CreatePostsUserLikesPostsRelationInput {
  connect: UserLikesPostWhereInput
  create: [UserLikesPostCreateWithoutPostInput!]
}

input CreatePostToUserRelationInput {
  connect: UserWhereInput
  create: UserCreateWithoutPostsInput
}

input CreateUserFollowsToFollowerRelationInput {
  connect: UserWhereInput
  create: UserCreateWithoutFolloweesInput
}

input CreateUserLikesPostToPostRelationInput {
  connect: PostWhereInput
  create: PostCreateWithoutUserLikesPostsInput
}

input CreateUserLikesPostToUserRelationInput {
  connect: UserWhereInput
  create: UserCreateWithoutPostsInput
}

input CreateUsersFolloweesRelationInput {
  connect: UserFollowsWhereInput
  create: [UserFollowsCreateWithoutFolloweeInput!]
}

input CreateUsersPostsRelationInput {
  connect: PostWhereInput
  create: [PostCreateWithoutUserInput!]
}

input CreateUsersUserLikesPostsRelationInput {
  connect: UserLikesPostWhereInput
  create: [UserLikesPostCreateWithoutUserInput!]
}

input CreateUserToEmailRelationInput {
  connect: EmailWhereInput
  create: EmailCreateWithoutUserInput
}

input CreateUserToProfileRelationInput {
  connect: UserProfileWhereInput
  create: UserProfileCreateWithoutUserInput
}

\\"\\"\\"
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
\`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
\\"\\"\\"
scalar DateTime

type Email {
  address: String!
  id: ID!
  user: User!
}

input EmailCreateWithoutUserInput {
  address: String!
}

input EmailWhereInput {
  address: String
  address_contains: String
  address_in: [String!]
  AND: [EmailWhereInput!]
  id: ID
  id_in: [ID!]
  NOT: [EmailWhereInput!]
  OR: [EmailWhereInput!]
}

type Mutation {
  createOneCategory(data: CategoryCreateInput!): Category!
  createOnePost(data: PostCreateInput!): Post!
  createOneUser(data: UserCreateInput!): User!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): UpdateManyResult!
  updateOneUser(data: UserUpdateInput!, where: UserWhereInput!): User!
}

type Post {
  categories(first: Int, last: Int, orderBy: [CategoryOrderByInput!], skip: Int, where: CategoryWhereInput): [Category!]!
  createdAt: DateTime!
  id: ID!
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: User!
  userId: Int
  userLikesPosts(first: Int, last: Int, orderBy: [UserLikesPostOrderByInput!], skip: Int, where: UserLikesPostWhereInput): [UserLikesPost!]!
  viewCount: Int
}

input PostCreateInput {
  categories: CreatePostsCategoriesRelationInput
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: CreatePostToUserRelationInput
  userId: Int
  userLikesPosts: CreatePostsUserLikesPostsRelationInput
  viewCount: Int
}

input PostCreateWithoutCategoriesInput {
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: CreatePostToUserRelationInput
  userId: Int
  userLikesPosts: CreatePostsUserLikesPostsRelationInput
  viewCount: Int
}

input PostCreateWithoutUserInput {
  categories: CreatePostsCategoriesRelationInput
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  userLikesPosts: CreatePostsUserLikesPostsRelationInput
  viewCount: Int
}

input PostCreateWithoutUserLikesPostsInput {
  categories: CreatePostsCategoriesRelationInput
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: CreatePostToUserRelationInput
  userId: Int
  viewCount: Int
}

enum PostOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isPublic_ASC
  isPublic_DESC
  liked_ASC
  liked_DESC
  title_ASC
  title_DESC
  totalLikes_ASC
  totalLikes_DESC
  userId_ASC
  userId_DESC
  viewCount_ASC
  viewCount_DESC
}

input PostWhereInput {
  AND: [PostWhereInput!]
  createdAt: DateTime
  createdAt_in: [DateTime!]
  id: ID
  id_in: [ID!]
  isPublic: Boolean
  isPublic_in: [Boolean!]
  liked: String
  liked_contains: String
  liked_in: [String!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  title: String
  title_contains: String
  title_in: [String!]
  totalLikes: Int
  totalLikes_gt: Int
  totalLikes_gte: Int
  totalLikes_in: [Int!]
  totalLikes_lt: Int
  totalLikes_lte: Int
  userId: Int
  userId_gt: Int
  userId_gte: Int
  userId_in: [Int!]
  userId_lt: Int
  userId_lte: Int
  viewCount: Int
  viewCount_gt: Int
  viewCount_gte: Int
  viewCount_in: [Int!]
  viewCount_lt: Int
  viewCount_lte: Int
}

type Query {
  category(orderBy: [CategoryOrderByInput!], where: CategoryWhereInput): Category!
  post(orderBy: [PostOrderByInput!], where: PostWhereInput): Post!
  posts(first: Int, last: Int, orderBy: [PostOrderByInput!], skip: Int, where: PostWhereInput): [Post!]!
  postsByCategoryId(categoryId: String!, first: Int, last: Int, orderBy: [PostOrderByInput!], skip: Int, where: PostWhereInput): [Post!]!
  user(orderBy: [UserOrderByInput!], where: UserWhereInput): User!
  users(first: Int, last: Int, orderBy: [UserOrderByInput!], skip: Int, where: UserWhereInput): [User!]!
  usersByName(first: Int, last: Int, name: String!, orderBy: [UserOrderByInput!], skip: Int, where: UserWhereInput): [User!]!
}

type UpdateManyResult {
  affectedRows: Int!
}

type User {
  age: Int
  email: Email!
  followees(first: Int, last: Int, orderBy: [UserFollowsOrderByInput!], skip: Int, where: UserFollowsWhereInput): [UserFollows!]!
  followers(first: Int, last: Int, orderBy: [UserFollowsOrderByInput!], skip: Int, where: UserFollowsWhereInput): [User!]!
  id: ID!
  name: String!
  posts(first: Int, last: Int, orderBy: [PostOrderByInput!], skip: Int, where: PostWhereInput): [Post!]!
  profile: UserProfile!
  type: UserTypeEnum!
  userLikesPosts(first: Int, last: Int, orderBy: [UserLikesPostOrderByInput!], skip: Int, where: UserLikesPostWhereInput): [UserLikesPost!]!
}

input UserCreateInput {
  age: Int
  email: CreateUserToEmailRelationInput
  followees: CreateUsersFolloweesRelationInput
  name: String!
  posts: CreateUsersPostsRelationInput
  profile: CreateUserToProfileRelationInput
  type: UserTypeEnum!
  userLikesPosts: CreateUsersUserLikesPostsRelationInput
}

input UserCreateWithoutFolloweesInput {
  age: Int
  email: CreateUserToEmailRelationInput
  name: String!
  posts: CreateUsersPostsRelationInput
  profile: CreateUserToProfileRelationInput
  type: UserTypeEnum!
  userLikesPosts: CreateUsersUserLikesPostsRelationInput
}

input UserCreateWithoutPostsInput {
  age: Int
  email: CreateUserToEmailRelationInput
  followees: CreateUsersFolloweesRelationInput
  name: String!
  profile: CreateUserToProfileRelationInput
  type: UserTypeEnum!
  userLikesPosts: CreateUsersUserLikesPostsRelationInput
}

type UserFollows {
  followee: User!
  followeeId: Int!
  follower: User!
  followerId: Int!
  id: ID!
}

input UserFollowsCreateWithoutFolloweeInput {
  follower: CreateUserFollowsToFollowerRelationInput
  followerId: Int!
}

enum UserFollowsOrderByInput {
  followeeId_ASC
  followeeId_DESC
  followerId_ASC
  followerId_DESC
  id_ASC
  id_DESC
}

input UserFollowsWhereInput {
  AND: [UserFollowsWhereInput!]
  followeeId: Int
  followeeId_gt: Int
  followeeId_gte: Int
  followeeId_in: [Int!]
  followeeId_lt: Int
  followeeId_lte: Int
  followerId: Int
  followerId_gt: Int
  followerId_gte: Int
  followerId_in: [Int!]
  followerId_lt: Int
  followerId_lte: Int
  id: ID
  id_in: [ID!]
  NOT: [UserFollowsWhereInput!]
  OR: [UserFollowsWhereInput!]
}

type UserLikesPost {
  id: ID!
  post: Post!
  postId: Int!
  user: User!
  userId: Int!
}

input UserLikesPostCreateWithoutPostInput {
  user: CreateUserLikesPostToUserRelationInput
  userId: Int!
}

input UserLikesPostCreateWithoutUserInput {
  post: CreateUserLikesPostToPostRelationInput
  postId: Int!
}

enum UserLikesPostOrderByInput {
  id_ASC
  id_DESC
  postId_ASC
  postId_DESC
  userId_ASC
  userId_DESC
}

input UserLikesPostWhereInput {
  AND: [UserLikesPostWhereInput!]
  id: ID
  id_in: [ID!]
  NOT: [UserLikesPostWhereInput!]
  OR: [UserLikesPostWhereInput!]
  postId: Int
  postId_gt: Int
  postId_gte: Int
  postId_in: [Int!]
  postId_lt: Int
  postId_lte: Int
  userId: Int
  userId_gt: Int
  userId_gte: Int
  userId_in: [Int!]
  userId_lt: Int
  userId_lte: Int
}

enum UserOrderByInput {
  age_ASC
  age_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
}

type UserProfile {
  displayName: String!
  id: ID!
  slug: String!
  user: User!
  userId: Int!
}

input UserProfileCreateWithoutUserInput {
  displayName: String!
  slug: String!
}

input UserProfileWhereInput {
  AND: [UserProfileWhereInput!]
  displayName: String
  displayName_contains: String
  displayName_in: [String!]
  id: ID
  id_in: [ID!]
  NOT: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  slug: String
  slug_contains: String
  slug_in: [String!]
  userId: Int
  userId_gt: Int
  userId_gte: Int
  userId_in: [Int!]
  userId_lt: Int
  userId_lte: Int
}

enum UserTypeEnum {
  ADMIN
  NORMAL
}

input UserUpdateInput {
  age: Int
  email: Int
  name: String
  type: UserTypeEnum
}

input UserWhereInput {
  age: Int
  age_gt: Int
  age_gte: Int
  age_in: [Int!]
  age_lt: Int
  age_lte: Int
  AND: [UserWhereInput!]
  id: ID
  id_in: [ID!]
  name: String
  name_contains: String
  name_in: [String!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  type: UserTypeEnum
  type_in: [UserTypeEnum!]
}
"
`;
